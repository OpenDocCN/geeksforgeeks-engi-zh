# 博客|从整体到微服务

> 原文:[https://www . geesforgeks . org/blog-从整体到微服务/](https://www.geeksforgeeks.org/blog-from-monolith-to-micro-services/)

如果你是一名软件工程师/开发人员，试想一下，当软件中的一个模块必须改变时，你会怎么做？
答案是**更换模块**。

但是几十年前，当模块化没有走在前列的时候，情况就有点不同了。
曾经有一段时间，软件就是我们所说的“单片”。将使用 [C](https://www.geeksforgeeks.org/c-programming-language/) 或 [C#](https://www.geeksforgeeks.org/csharp-programming-language/) 或其他[程序语言](https://www.geeksforgeeks.org/introduction-of-programming-paradigms/)编写的单个相关应用程序，无论何时需要对其进行更新，都必须完全删除并重新安装到服务器上。这就是我们过去享受服务的时候。这些应用程序过去非常快，但更新期间的停机时间仍然是一个大问题。
因此分解器以**负载平衡器**的形式出现。

不再使用 1 台或 2 台服务器，而是增加了服务器的数量。这在两个方面有所帮助:
对于服务来说，流量并不总是相同的。因此，只要流量高，服务器之间的负载就会平衡，而在流量低的时候，一台服务器就会正常工作。这减少了资源浪费，提供了备份，并在高峰时段处理了大量流量。

接下来，最大的优势是，现在无论何时需要更新软件，它都从一半的服务器上删除，而不是从整体上删除应用程序。因此，假设应用程序在 4 台服务器上运行，在流量较低的时候，2 台服务器将关闭，2 台将启动。然后在 2 台关闭的服务器上更新应用程序，然后对其他 2 台服务器重复该过程。因此用户从未有过停机时间。

但这也没有完全解决问题，因为整个应用程序仍在被替换，这仍然不是理想的情况。

随后，随着编程实践中模块化的出现，甲骨文推出了 [J2EE](https://www.geeksforgeeks.org/j2se-vs-j2me-vs-j2ee-whats-the-difference/) ，即 Java 平台企业版。这很有帮助，因为它提供了服务选择、数据库、简化的体系结构和与现有信息系统的集成。这导致了甲骨文在这一领域的垄断，与之相对应的是产生了微服务的想法。

我们今天在应用程序中看到的是微服务的最佳使用。
不是改变整个应用，现在只是改变要更新的模块，应用的其余部分始终启动并运行。这可以通过[微服务](https://www.geeksforgeeks.org/microservices-introduction/)架构来实现，通过在架构方法中提供具有这些属性的服务集合，使应用程序松散耦合，围绕业务能力进行组织，并且高度可维护。

最后，我们有了现在的应用形式，高度模块化，可维护，易于更新，这要归功于**整体应用**的悠久历史。