# 软件工程中良好用户界面的特征

> 原文:[https://www . geesforgeks . org/软件工程中良好用户界面的特征/](https://www.geeksforgeeks.org/characteristics-of-good-user-interface-in-software-engineering/)

**用户界面设计:**

通过软件程序的用户界面设计，用户与软件程序的交互是可行的。没有没有用户界面的软件。因为它处理用户与软件的交互，所以它是任何软件开发的一个非常重要的部分。在许多应用程序中，50%的整体改进尝试在人员界面部分最有效。

![](img/ba30a518de8f773cf6ebe4530cc8c391.png)

**用户界面设计流程**

**良好用户界面设计的特征:**

**学习速度:**
好的用户界面设计容易学。通过使用命令发布过程的复杂语法和语义，学习速度正在提高。没有必要在一个好的用户界面中学习用户的命令。一个好的用户界面也不允许它的用户在做任何事情的时候记住不同屏幕的信息

**以下两种方法对提高学习速度至关重要:**

*   **Use of metaphors and intuitive command names –**
    Metaphor is just like the abstraction of items like real-existence that is used with inside person interface. If textual content editor of the person interface makes use of the identical ideas or we will say equipment for the modifying of textual content like reducing strains and paragraphs and additionally pasting distinctive textual content at distinctive places, then it could be without difficulty associated through the person. 

    同样，还有一种其他形式的著名比喻，叫做购物车。杂货店内的人可以使用购物车购买不同的商品，同时购买不同的商品。对于场景的设计，其中类似形式的备选方案将通过客户端进行，并且人界面为此目的使用购物车隐喻，那么客户可以毫无困难地理解和发现使用界面的方法。还可以通过使用直观的命令名称和符号化的命令麻烦程序来推进学习。

*   **基于组件的界面–**
    如果界面全新的交互方式变成了非常像人已经熟悉的不同程序的界面，可能会让人理解起来很流畅。如果通过使用几个首选的界面组件来改进独特的交互式个人界面，这是可行的、最有效的。

**使用速度:**
用户界面的使用速度取决于启动和执行不同命令所用的时间和精力。它有时被称为生产力支持，在这种支持下，用户可以有很多时间来执行他的任务。要启动和执行不同的命令，必须减少用户和时间的工作量。只有通过使用设计合理的用户界面才能实现。

**召回速度:**
多次使用界面后，召回任何命令的速度都会自动增加。他们调用命令发布程序的速度应该最大化。有许多方法可以提高回忆速度，比如使用一些隐喻、符号命令发布过程和直观的命令名称。

**错误预防:**
正如我们所理解的预防高于治疗。所以对于准确的错误，挽救你的错误要有用得多。一个好的用户界面必须通过使用各种指令来减少犯错误的范围。通过跟踪普通客户发生的错误，可以毫无困难地确定错误费用。通过使用跟踪代码自动化人员界面代码，这有利于记录频率和失误种类，并在此之后通过用户显示失误信息。

**审美和吸引力:**
众所周知，有吸引力的东西会获得更多的关注。因此，一个好的用户界面应该有吸引力。因此，基于图形的用户界面比基于文本的界面更受欢迎。

**反馈:**
对人的动作提供注释有助于人理解系统的处理。如果用户的任何请求需要几秒钟以上，那么用户就会开始恐慌，这就是正在发生的事情，如果向用户提供了适当的反馈，那么他必须知道自己的行为。因此，一个好的用户界面必须包含关于处理的反馈。

**错误恢复:**
错误可能很常见，所有人都会犯错误，即使是专家也会犯错误。因此，一个优秀的人界面也有责任提供一个撤销工具，以便这个人可以在使用界面的同时更好地处理他们的错误。如果错误不能通过用户恢复，他们会感到恼怒、无助和低落。

**用户指导和在线帮助:**
一个好的用户界面是这样的:当用户忽略某个命令之类的东西时，或者当他们不知道软件程序的功能时，它还会为用户提供帮助。这可以通过提供精确的用户正在寻求的转向和在线协助来实现。