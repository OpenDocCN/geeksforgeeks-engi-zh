# 软件测试中的面向对象测试

> 原文:[https://www . geesforgeks . org/面向对象-软件测试-测试/](https://www.geeksforgeeks.org/object-oriented-testing-in-software-testing/)

先决条件–[软件测试](https://www.geeksforgeeks.org/software-testing-basics/)
软件通常经历许多级别的测试，从单元测试到系统或验收测试。通常，在- [单元测试](https://www.geeksforgeeks.org/unit-testing-software-testing/)中，软件的小“单元”或模块被单独测试，重点是测试该模块的代码。在更高阶的测试中(例如[验收测试](https://www.geeksforgeeks.org/acceptance-testing-software-testing/)，整个系统(或一个子系统)的测试重点是测试系统的功能或外部行为。

随着信息系统变得越来越复杂，面向对象的范例越来越受欢迎，因为它在分析、设计和编码方面具有优势。由于测试类、抽象类、继承、动态绑定、消息、传递、多态、并发等涉及的问题，传统的测试方法无法应用于测试类。
测试类与测试函数是一个根本不同的问题。函数(或过程)有明确定义的输入输出行为，而类没有输入输出行为规范。我们可以使用测试函数的方法来测试一个类的方法，但是我们不能使用这些
方法来测试这个类。

根据戴维斯的说法，传统系统中出现的依赖关系是:

*   变量之间的数据依赖关系
*   调用模块之间的依赖关系
*   模块和它计算的变量之间的函数依赖关系
*   变量与其类型之间的定义依赖关系。

但是在面向对象的系统中，还有以下附加的依赖性:

*   类到类的依赖关系
*   类到方法的依赖关系
*   类到消息的依赖关系
*   类到变量的依赖关系
*   变量依赖关系的方法
*   方法对消息的依赖关系
*   方法到方法的依赖关系

**测试类中的问题:**
因此，需要额外的测试技术来测试这些依赖关系。另一个感兴趣的问题是，不可能动态地测试类，只有它的实例，即对象可以被测试。类似地，继承的概念会引发各种问题，例如，如果对父类或超类进行了更改，那么在一个更大的类系统中，将很难单独测试子类并将错误隔离到一个类中。

在面向对象程序中，控制流的特征是对象之间的消息传递，控制流通过对象间的通信从一个对象切换到另一个对象。因此，类内没有类似函数的控制流。一个类中缺乏顺序控制流需要不同的测试方法。此外，在函数中，用全局数据传递给函数的参数决定了过程中的执行路径。但是，在对象中，与该对象相关联的状态也会影响执行路径，并且类的方法可以通过该状态在它们之间进行通信，因为该状态在方法调用之间是持久的。因此，对于测试对象，对象的状态必须发挥重要作用。

面向对象测试的技术如下:

1.  **Fault Based Testing:**
    This type of checking permits for coming up with test cases supported the consumer specification or the code or both. It tries to identify possible faults (areas of design or code that may lead to errors.). For all of these faults, a test case is developed to “flush” the errors out. These tests also force each time of code to be executed.

    这种测试方法不能发现所有类型的错误。但是，可能会遗漏不正确的规范和接口错误。这些类型的错误可以通过传统测试模型中的功能测试来发现。在面向对象模型中，交互错误可以通过基于场景的测试来发现。这种形式的面向对象测试只能针对客户端的规范进行测试，因此仍然会遗漏接口错误。

2.  **基于方法测试的类测试:**
    这种方法是测试类最简单的方法。该类的每个方法都执行一个定义良好的内聚功能，因此可以与传统测试技术的单元测试相关联。因此，一个类的所有方法都可以至少参与一次来测试这个类。
3.  **随机测试:**
    它是通过开发一个随机测试序列来支持的，该序列尝试了类别行为中典型的最少操作种类
4.  **划分测试:**
    这种方法对一个类别的输入和输出进行分类，以便对它们进行严格检查。这可以最大限度地减少需要设计的案例数量。
5.  **基于场景的测试:**
    它主要涉及捕获用户动作，然后在整个测试过程中激励他们做出类似的动作。
    这些测试倾向于寻找错误的交互形式。