# 什么是混淆？

> 原文:[https://www.geeksforgeeks.org/what-is-obfuscation/](https://www.geeksforgeeks.org/what-is-obfuscation/)

**混淆**是软件工程中的一个知名术语。它是程序员有目的地隐藏编写的代码。它主要是出于安全目的，通过使它变得模糊来避免篡改、隐藏隐式值或隐藏所使用的逻辑。人们可以在特定语言的 deobfuscators 的帮助下混淆代码，这些 deobfuscators 可以转换成有意义的代码。

**例如:**

*   下面是一个模糊的 C 代码:

    ```
    int i;main(){for(i=0;i["]<i;++i){--i;}"];
    read('-'-'-',i+++"hell\
    o,world!\n",'/'/'/'));}read(j,i,p){
    write(j/p+p,i---j,i/i);} 
    ```

*   这是一个人能理解的版本。

    ```
    int i;

    void write_char(char ch)
    {
        printf("%c", ch);
    }

    int main()
    {
        for (i = 0; i < 15; i++) {
            write_char("hello, world!\n"[i]);
        }
        return 0;
    }
    ```

**如何在应用中混淆代码？**
要理解混淆，我们需要知道安卓和 Java 是如何实现这种应用内信息的。有两种方法可以混淆应用程序中的代码:

1.  **收缩:**它有助于检测并安全地从应用的发布版本中移除未使用的类、字段、方法和属性。
2.  **优化:**它有助于检查和重写代码，以减少其大小。例如，如果优化器检测到一条 if-else 语句，其中 else {}语句从未使用过，则 else 语句的代码将被删除。代码收缩器和优化器的例子是 Java 和安卓的 ProGuard 和安卓的 R8。

**如何确定混淆方法的质量？**
混淆方法的质量是由其效力、韧性、隐蔽性和成本的组合决定的。

1.  **隐身:**需要隐藏一个程序的控制流。
2.  **成本:**成本效益是必要的，这样混淆技术可以在几个类似的应用中大规模应用。
3.  **效能:**效能定义了转换后的代码比原始代码更模糊的程度。软件复杂性度量定义了软件的各种复杂性度量，例如它包含的谓词数量、继承树的深度、嵌套级别等。好的软件设计的目标是基于这些参数最小化复杂性，而混淆的目标是最大化复杂性。
4.  **恢复力:**恢复力定义了转换后的代码能够在多大程度上抵抗自动脱壳攻击。它是程序员努力创建一个变形器和变形器所需的时间和空间的结合。最大程度的恢复力是单向的转变，不能被变形者破坏。一个例子是当模糊处理移除诸如源代码格式等信息时。

**混淆的优势:**

*   用于混淆的一个著名方法是**迭代代码混淆**。在许多应用程序中，迭代代码混淆是一个过程，其中一个或多个混淆算法被重复应用于代码，前一个混淆算法的输出为下一个混淆算法提供输入。这可以称为**为代码**增加安全层的一种方式。
*   如果一个人正在发布有价值的软件(尤其是 Java、Android、。NET 和 iOS)在他或她直接控制之外的任何地方，并且源代码没有被分发，混淆可能应该是应用程序开发过程的一部分。**混淆使得攻击者更难查看代码和分析应用程序**。这也可能使黑客很难调试和篡改您的应用程序。最终目标是使从应用程序中提取或发现有用信息变得困难，例如商业秘密(IP)、凭据或安全漏洞。

**模糊处理的缺点:**
模糊处理也被网络犯罪分子使用。让我们看看如何保护自己免受它们的伤害。

*   恶意软件作者广泛使用混淆来逃避防病毒扫描程序。分析这些混淆技术如何在恶意软件中使用是至关重要的。
*   **死代码插入**:这是一种简单的基本技术，通过向程序添加无效指令来改变其外观，而不是改变其行为。为了对抗死代码插入，基于签名的反病毒扫描程序应该能够在分析之前删除无效的指令。
*   **指令子程序**:这种混淆技术通过用原始指令的其他等价物替换一些指令来确保原始代码的进化。
*   **代码传输**:代码转置采用原始代码指令序列的重新排序，而不会对代码的行为产生任何可见的影响。本质上，有两种方法可以将这种技术付诸行动。第一种方法是随机打乱指令，通过插入无条件分支或跳转继续恢复原始执行顺序。对抗这种混淆的一种方法是通过移除无条件分支或跳转来恢复原始程序。相比之下，第二种方法通过选择和重新排序对彼此没有影响的自由指令来创建新的世代。寻找免费的指令是一个复杂的问题。这种方法很难实现，而且检测成本也很高。
*   **代码集成**:代码集成最早是由 Win95/Zmist 恶意软件(又称 Zmist)引入的。Zmits 恶意软件将其自身绑定到其目标程序的代码上。为了执行这种混淆技术，Zmist 必须首先将其目标程序反编译成可管理的小对象，并在它们之间插入自己，然后将集成代码重新组装成新一代代码。到目前为止，这是最复杂的混淆技术之一，可能会使检测和恢复非常困难，并且成本高昂。